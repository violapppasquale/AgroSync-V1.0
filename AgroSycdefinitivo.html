<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>AgroSync – Piantagione & Recinzione (Google Maps)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Turf.js per le operazioni geospaziali -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root {
      --bg: #0f1115;
      --panel: #151925;
      --muted: #98a2b3;
      --text: #e6e8ee;
      --accent: #7c9cff;
      --ok: #56d364;
      --warn: #ffb454;
      --err: #ff6b6b;
      --border: #22304a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height: 1.35;
    }
    header {
      padding: 16px 20px; border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #121725, #0f1115);
      position: sticky; top: 0; z-index: 10;
      display: flex; align-items: center; gap: 12px;
    }
    header h1 { margin: 0; font-size: 18px; letter-spacing: .4px; }
    header small { color: var(--muted); }
    .wrap {
      display: grid; grid-template-columns: 440px 1fr; gap: 14px; padding: 14px;
      height: calc(100vh - 58px);
    }
    aside {
      background: var(--panel); border: 1px solid var(--border); border-radius: 16px;
      padding: 14px; overflow: auto;
    }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    textarea, input, select {
      width: 100%; border-radius: 12px; border: 1px solid var(--border);
      background: #0d1220; color: var(--text); padding: 10px 12px; outline: none;
    }
    textarea { min-height: 90px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btn {
      width: 100%; padding: 12px 14px; border-radius: 12px; border: 1px solid var(--border);
      background: #0d1220; color: var(--text); cursor: pointer; font-weight: 600;
      transition: .15s transform ease, .2s background ease;
    }
    .btn:hover { transform: translateY(-1px); background: #0f1528; }
    .btn.primary { background: var(--accent); border-color: transparent; color: #0b1020; }
    .btn.primary:hover { filter: brightness(1.04); }
    .btn.ghost { background: transparent; }
    .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .note { font-size: 12px; color: var(--muted); }
    .stat {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;
    }
    .card {
      border: 1px solid var(--border); border-radius: 12px; padding: 10px;
      background: #0d1220;
    }
    .card h4 { margin: 0 0 8px; font-size: 13px; color: #c7d2fe; }
    .value { font-size: 18px; font-weight: 700; }
    .tag { font-size: 11px; color: var(--muted); }
    .warn { color: var(--warn); }
    .err  { color: var(--err); }
    #map { width: 100%; height: 100%; border: 1px solid var(--border); border-radius: 16px; }
    .pill {
      display: inline-block; padding: 4px 8px; border-radius: 999px; font-size: 11px;
      border: 1px solid var(--border); color: var(--muted); margin-left: 6px;
    }
    .legend { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; font-size: 12px; color: var(--muted); }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
    .dot.border { background: #2b3756; }
    .dot.work   { background: #365a20; }
    .dot.point  { background: #9cc3ff; }
    .dot.gps    { background: #56d364; }
    .hr { height: 1px; background: var(--border); margin: 12px 0; opacity: .6; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <h1>AgroSync – Piantagione & Recinzione <small class="pill">Demo locale</small></h1>
    <small id="gpsStatus" class="pill">GPS: inattivo</small>
  </header>

  <div class="wrap">
    <aside>
      <div class="field">
        <label>Modalità</label>
        <select id="mode">
          <option value="planting">Piantagione (griglia)</option>
          <option value="fence">Recinzione (solo bordo)</option>
        </select>
      </div>

      <div class="field">
        <label>Coordinate del terreno (una per riga: <code>lat,lng</code>)</label>
        <textarea id="coords" placeholder="Esempio:
38.90550,16.58672
38.90521,16.58902
38.90394,16.58846"></textarea>
        <div class="note">Puoi anche <b>cliccare sulla mappa</b> per aggiungere vertici. Minimo 3 punti.</div>
      </div>

      <!-- Parametri PIANTAGIONE -->
      <div id="plantingParams">
        <div class="row">
          <div class="field">
            <label>Distanza tra piante (metri)</label>
            <input type="number" id="spacing" value="6" min="0.5" step="0.1">
          </div>
          <div class="field">
            <label>Margine dal bordo (metri)</label>
            <input type="number" id="margin" value="2" min="0" step="0.1">
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label>Orientamento griglia</label>
            <select id="orientation">
              <option value="edge">Allinea al primo lato del poligono</option>
              <option value="north">Allinea Nord–Sud / Est–Ovest</option>
            </select>
          </div>
          <div class="field">
            <label>Limite massimo punti (performance)</label>
            <input type="number" id="maxPoints" value="4000" min="100" step="100">
          </div>
        </div>
      </div>

      <!-- Parametri RECINZIONE -->
      <div id="fenceParams" class="hidden">
        <div class="row">
          <div class="field">
            <label>Distanza tra paletti (metri)</label>
            <input type="number" id="fenceSpacing" value="4" min="0.5" step="0.1">
          </div>
          <div class="field">
            <label>Opzioni recinzione</label>
            <select id="fenceIncludeCorners">
              <option value="yes" selected>Includi vertici (angoli)</option>
              <option value="no">Solo punti equidistanti (no angoli)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="btn-row">
        <button class="btn" id="btnAddFromMap">Aggiunta da mappa: <b>ATTIVA</b></button>
        <button class="btn ghost" id="btnClear">Pulisci vertici</button>
      </div>

      <div class="btn-row" style="margin-top:10px">
        <button class="btn primary" id="btnCompute">Calcola & Disegna</button>
        <button class="btn" id="btnExport">Esporta CSV</button>
      </div>

      <div class="hr"></div>

      <!-- GPS -->
      <div class="row">
        <button class="btn" id="btnGPS">Avvia GPS</button>
        <button class="btn ghost" id="btnFollow" disabled>Segui posizione</button>
      </div>
      <div class="note" id="gpsInfo" style="margin-top:6px;">—</div>

      <div class="legend">
        <span><span class="dot border"></span>Terreno</span>
        <span id="legendWork"><span class="dot work"></span>Area utile (bordo−margine)</span>
        <span><span class="dot point"></span>Punti generati</span>
        <span><span class="dot gps"></span>Posizione utente</span>
      </div>

      <div class="hr"></div>

      <div class="stat">
        <div class="card">
          <h4>Superficie Terreno</h4>
          <div class="value" id="areaTot">—</div>
          <div class="tag">m² (e ha)</div>
        </div>
        <div class="card">
          <h4 id="metricTitle">Superficie Utile</h4>
          <div class="value" id="metricValue">—</div>
          <div class="tag" id="metricTag">m²</div>
        </div>
        <div class="card">
          <h4>Punti Totali</h4>
          <div class="value" id="pointCount">—</div>
          <div class="tag">piante o paletti</div>
        </div>
        <div class="card">
          <h4>Stato</h4>
          <div id="status" class="tag">In attesa di calcolo…</div>
        </div>
      </div>
    </aside>

    <div id="map"></div>
  </div>

  <!-- Google Maps JS (inserisci la tua API key) -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwo0r8Kd1FVCNxFmsrZ9OqcuJsAqa_v-Q&libraries=geometry&v=quarterly&callback=initMap">
  </script>

  <script>
    let map, drawPolygon, workPolygon, clickListener = null;
    let vertexMarkers = [];
    let pointOverlays = []; // Marker dei punti (piante/paletti)
    let currentPath = [];
    let addFromMap = true;
    let lastPoints = []; // per export
    let mode = 'planting';

    // GPS
    let watchId = null;
    let followPos = false;
    let userMarker = null;
    let userAccuracy = null;

    // Utilità
    const $ = (id) => document.getElementById(id);
    const fmt = (n) => new Intl.NumberFormat('it-IT', { maximumFractionDigits: 2 }).format(n);

    // Inizializza la mappa
    window.initMap = function() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 38.905, lng: 16.588 },
        zoom: 16,
        mapTypeId: 'hybrid',
        tilt: 0,
        streetViewControl: false,
        mapTypeControl: true,
        fullscreenControl: true,
      });

      // Poligoni con zIndex basso (punti sempre sopra)
      drawPolygon = new google.maps.Polygon({
        paths: [],
        strokeColor: '#3d5afe',
        strokeOpacity: 0.9,
        strokeWeight: 2,
        fillColor: '#2b3756',
        fillOpacity: 0.25,
        clickable: false,
        map,
        zIndex: 1
      });

      workPolygon = new google.maps.Polygon({
        paths: [],
        strokeColor: '#7cd67a',
        strokeOpacity: 0.9,
        strokeWeight: 2,
        fillColor: '#365a20',
        fillOpacity: 0.25,
        clickable: false,
        map,
        zIndex: 0
      });

      enableMapClick(true);
      bindUI();
      updateModeUI();
    };

    function bindUI() {
      $('mode').addEventListener('change', () => {
        mode = $('mode').value;
        updateModeUI();
      });

      $('btnAddFromMap').addEventListener('click', () => {
        addFromMap = !addFromMap;
        $('btnAddFromMap').innerHTML = addFromMap ? 'Aggiunta da mappa: <b>ATTIVA</b>' : 'Aggiunta da mappa: <b>SPENTA</b>';
        enableMapClick(addFromMap);
      });

      $('btnClear').addEventListener('click', () => {
        clearAll();
        setStatus('Pulito. Inserisci nuovi vertici o clicca sulla mappa.');
      });

      $('btnCompute').addEventListener('click', () => {
        parseTextareaIntoPath();
        if (currentPath.length < 3) { setError('Inserisci almeno 3 vertici.'); return; }
        if (mode === 'planting') computeAndRenderPlanting();
        else computeAndRenderFence();
      });

      $('btnExport').addEventListener('click', () => {
        if (!lastPoints.length) { setError('Nessun punto da esportare. Esegui il calcolo.'); return; }
        exportCSV(lastPoints, mode === 'planting' ? 'punti_piantagione.csv' : 'punti_recinzione.csv');
      });

      $('coords').addEventListener('input', () => {
        parseTextareaIntoPath();
        renderVertices();
      });

      // GPS
      $('btnGPS').addEventListener('click', toggleGPS);
      $('btnFollow').addEventListener('click', () => {
        followPos = !followPos;
        $('btnFollow').textContent = followPos ? 'Segui posizione (ON)' : 'Segui posizione';
      });
    }

    function updateModeUI() {
      const planting = mode === 'planting';
      $('plantingParams').classList.toggle('hidden', !planting);
      $('fenceParams').classList.toggle('hidden', planting);

      // Aggiorna legenda e metriche
      $('legendWork').style.visibility = planting ? 'visible' : 'hidden';
      $('metricTitle').textContent = planting ? 'Superficie Utile' : 'Perimetro Terreno';
      $('metricTag').textContent   = planting ? 'm²' : 'metri';
      $('metricValue').textContent = '—';
      $('pointCount').textContent = '—';
      setStatus('Modalità: ' + (planting ? 'Piantagione' : 'Recinzione') + '.');
    }

    function enableMapClick(on) {
      if (clickListener) { clickListener.remove(); clickListener = null; }
      if (on) {
        clickListener = map.addListener('click', (ev) => {
          const lat = ev.latLng.lat(), lng = ev.latLng.lng();
          currentPath.push({ lat, lng });
          appendToTextarea(lat, lng);
          renderVertices();
        });
      }
    }

    function appendToTextarea(lat, lng) {
      const t = $('coords');
      const line = `${lat.toFixed(6)},${lng.toFixed(6)}`;
      t.value = (t.value.trim() ? (t.value.trim() + '\n') : '') + line;
    }

    function parseTextareaIntoPath() {
      const lines = $('coords').value
        .split('\n')
        .map(x => x.trim())
        .filter(Boolean);
      const pts = [];
      for (const line of lines) {
        const parts = line.split(/[,;\s]+/).map(Number);
        if (parts.length >= 2 && isFinite(parts[0]) && isFinite(parts[1])) {
          pts.push({ lat: parts[0], lng: parts[1] });
        }
      }
      currentPath = pts;
    }

    function clearAll() {
      $('coords').value = '';
      currentPath = [];
      lastPoints = [];
      clearMarkers();
      clearPointOverlays();
      drawPolygon.setPath([]);
      workPolygon.setPath([]);
      $('areaTot').textContent = '—';
      $('metricValue').textContent = '—';
      $('pointCount').textContent = '—';
    }

    function clearMarkers() {
      vertexMarkers.forEach(m => m.setMap(null));
      vertexMarkers = [];
    }
    function clearPointOverlays() {
      pointOverlays.forEach(o => o.setMap(null));
      pointOverlays = [];
    }

    function renderVertices() {
      clearMarkers();
      drawPolygon.setPath(currentPath);
      currentPath.forEach((p, i) => {
        const m = new google.maps.Marker({
          position: p,
          label: String(i + 1),
          map,
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 5,
            fillColor: '#9cc3ff',
            fillOpacity: 1,
            strokeColor: '#0b1020',
            strokeWeight: 1
          }
        });
        vertexMarkers.push(m);
      });
      if (currentPath.length) {
        const bounds = new google.maps.LatLngBounds();
        currentPath.forEach(p => bounds.extend(p));
        map.fitBounds(bounds);
      }
    }

    function setStatus(msg) { $('status').textContent = msg; $('status').className = 'tag'; }
    function setWarn(msg) { $('status').textContent = msg; $('status').className = 'tag warn'; }
    function setError(msg) { $('status').textContent = msg; $('status').className = 'tag err'; }

    function toTurfPolygon(path) {
      const ring = path.map(p => [p.lng, p.lat]);
      const first = ring[0], last = ring[ring.length - 1];
      if (!first || !last) return null;
      if (first[0] !== last[0] || first[1] !== last[1]) ring.push([first[0], first[1]]);
      return turf.polygon([ring]);
    }

    // ---------- PIANTAGIONE ----------
    function computeAndRenderPlanting() {
      try {
        const spacing = Math.max(0.1, Number($('spacing').value));
        const margin = Math.max(0, Number($('margin').value));
        const orientation = $('orientation').value;
        const maxPoints = Math.max(100, Number($('maxPoints').value));

        const poly = toTurfPolygon(currentPath);
        if (!poly) { setError('Poligono non valido.'); return; }

        // Aree
        const areaTot_m2 = turf.area(poly);
        $('areaTot').textContent = `${fmt(areaTot_m2)} m² (${fmt(areaTot_m2/10000)} ha)`;

        // Buffer negativo per area utile
        let work = margin > 0 ? turf.buffer(poly, -margin, { units: 'meters', steps: 16 }) : poly;
        if (!work || (work.geometry.type !== 'Polygon' && work.geometry.type !== 'MultiPolygon')) {
          setWarn('Margine troppo grande: area utile nulla. Riduci il margine.');
          workPolygon.setPath([]);
          $('metricValue').textContent = '0';
          $('pointCount').textContent = '0';
          clearPointOverlays();
          return;
        }

        if (work.geometry.type === 'MultiPolygon') {
          let biggest = null, maxA = 0;
          turf.flatten(work).features.forEach(f => {
            const a = turf.area(f);
            if (a > maxA) { maxA = a; biggest = f; }
          });
          work = biggest || turf.polygon([]);
        }

        const areaWork_m2 = turf.area(work);
        $('metricValue').textContent = `${fmt(areaWork_m2)} m²`;

        // Orientamento
        const centroid = turf.centroid(work);
        let thetaDeg = 0;
        if (orientation === 'edge' && currentPath.length >= 2) {
          const p1 = currentPath[0], p2 = currentPath[1];
          thetaDeg = turf.bearing([p1.lng, p1.lat], [p2.lng, p2.lat]);
        } else {
          thetaDeg = 0;
        }

        // Ruota l'area utile per allineare la griglia agli assi
        const workRot = turf.transformRotate(work, -thetaDeg, { pivot: centroid });

        // bbox e griglia
        const bbox = turf.bbox(workRot);
        let grid = turf.pointGrid(bbox, spacing, { units: 'meters' });

        // Limita densità
        const bboxWidth = turf.distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], {units:'meters'});
        const bboxHeight = turf.distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], {units:'meters'});
        const bboxAreaApprox = bboxWidth * bboxHeight;
        const ballpark = bboxAreaApprox / (spacing*spacing);
        if (ballpark > maxPoints * 2) {
          const factor = Math.sqrt(ballpark / (maxPoints * 1.2));
          const newSpacing = spacing * factor;
          grid = turf.pointGrid(bbox, newSpacing, { units: 'meters' });
          setWarn(`Molti punti: spacing adattato ≈ ${fmt(newSpacing)} m per performance.`);
        } else {
          setStatus('Griglia generata.');
        }

        // Filtra dentro l'area ruotata e riporta i punti alla rotazione originale
        const inside = turf.pointsWithinPolygon(grid, workRot);
        const ptsBack = turf.transformRotate(inside, thetaDeg, { pivot: centroid });

        // Render su mappa
        renderPolygons(poly, work);
        renderPoints(ptsBack);

        $('pointCount').textContent = fmt(ptsBack.features.length);
        setStatus(`Piantagione completata: ${ptsBack.features.length} punti.`);
      } catch (e) {
        console.error(e);
        setError('Errore nel calcolo (piantagione). Controlla i dati inseriti.');
      }
    }

    // ---------- RECINZIONE ----------
    function computeAndRenderFence() {
      try {
        const spacing = Math.max(0.1, Number($('fenceSpacing').value));
        const includeCorners = $('fenceIncludeCorners').value === 'yes';

        const poly = toTurfPolygon(currentPath);
        if (!poly) { setError('Poligono non valido.'); return; }

        // Superficie e perimetro
        const areaTot_m2 = turf.area(poly);
        $('areaTot').textContent = `${fmt(areaTot_m2)} m² (${fmt(areaTot_m2/10000)} ha)`;

        const polyLine = turf.polygonToLine(poly);
        const perim_m = turf.length(polyLine, { units: 'kilometers' }) * 1000;
        $('metricValue').textContent = `${fmt(perim_m)} m`;

        // Genera punti lungo il bordo
        const ring = poly.geometry.coordinates[0]; // [lng, lat], chiuso
        let coords = [];
        for (let i = 0; i < ring.length - 1; i++) {
          const A = ring[i], B = ring[i+1];
          const seg = turf.lineString([A, B]);
          const segLen_m = turf.length(seg, { units: 'kilometers' }) * 1000;

          // Aggiungi A solo sul primo segmento (come vertice iniziale)
          if (i === 0 && includeCorners) coords.push(A);

          // Punti equidistanti sul segmento
          for (let d = spacing; d < segLen_m - 1e-6; d += spacing) {
            const p = turf.along(seg, d / 1000, { units: 'kilometers' });
            coords.push(p.geometry.coordinates);
          }

          // Aggiungi B (angolo) su tutti i segmenti tranne l'ultimo per evitare duplicato dell'origine
          if (includeCorners && i < ring.length - 2) coords.push(B);
        }

        // FeatureCollection dai punti
        const pts = turf.featureCollection(coords.map(([lng, lat]) => turf.point([lng, lat])));

        // Render (workPolygon non usato in recinzione)
        renderPolygons(poly, null);
        renderPoints(pts);

        $('pointCount').textContent = fmt(pts.features.length);
        setStatus(`Recinzione completata: ${pts.features.length} paletti generati.`);
      } catch (e) {
        console.error(e);
        setError('Errore nel calcolo (recinzione). Controlla i dati inseriti.');
      }
    }

    function renderPolygons(poly, work) {
      // Terreno
      const ring = poly.geometry.coordinates[0].map(([lng, lat]) => ({ lat, lng }));
      drawPolygon.setPath(ring);

      // Area utile (solo in piantagione)
      if (work) {
        const paths = [];
        if (work.geometry.type === 'Polygon') {
          work.geometry.coordinates.forEach(r =>
            paths.push(r.map(([lng, lat]) => ({ lat, lng })))
          );
        } else if (work.geometry.type === 'MultiPolygon') {
          work.geometry.coordinates.forEach(polyC =>
            polyC.forEach(r => paths.push(r.map(([lng, lat]) => ({ lat, lng }))))
          );
        }
        workPolygon.setPaths(paths);
        workPolygon.setMap(map);
      } else {
        workPolygon.setPaths([]);
        workPolygon.setMap(null);
      }

      const bounds = new google.maps.LatLngBounds();
      ring.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);
    }

    // ---- PUNTI: Marker SVG (sempre sopra) ----
    function renderPoints(fcPoints) {
      clearPointOverlays();
      lastPoints = [];
      for (const f of fcPoints.features) {
        const [lng, lat] = f.geometry.coordinates;
        lastPoints.push({ lat, lng });

        const marker = new google.maps.Marker({
          map,
          position: { lat, lng },
          icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 4.5,               // ~9 px
            fillColor: '#9cc3ff',
            fillOpacity: 1,           // opacità piena uniforme
            strokeColor: '#0b1020',
            strokeWeight: 1
          },
          clickable: false,
          zIndex: google.maps.Marker.MAX_ZINDEX + 1000
        });

        pointOverlays.push(marker);
      }
    }

    function exportCSV(points, filename) {
      const header = 'lat,lng\n';
      const rows = points.map(p => `${p.lat},${p.lng}`).join('\n');
      const blob = new Blob([header + rows], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename || 'punti.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // ---------- GPS in tempo reale ----------
    function toggleGPS() {
      if (watchId != null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
        followPos = false;
        $('btnFollow').disabled = true;
        $('btnFollow').textContent = 'Segui posizione';
        $('btnGPS').textContent = 'Avvia GPS';
        $('gpsStatus').textContent = 'GPS: inattivo';
        $('gpsInfo').textContent = '—';
        if (userMarker) { userMarker.setMap(null); userMarker = null; }
        if (userAccuracy) { userAccuracy.setMap(null); userAccuracy = null; }
        return;
      }

      if (!('geolocation' in navigator)) {
        setError('Geolocalizzazione non supportata dal browser.');
        return;
      }

      $('btnGPS').textContent = 'Ferma GPS';
      $('gpsStatus').textContent = 'GPS: attivo';

      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const { latitude, longitude, accuracy } = pos.coords;
          const latlng = { lat: latitude, lng: longitude };
          if (!userMarker) {
            userMarker = new google.maps.Marker({
              position: latlng, map,
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 6,
                fillColor: '#56d364',
                fillOpacity: 1,
                strokeColor: '#0b1020',
                strokeWeight: 1
              },
              zIndex: google.maps.Marker.MAX_ZINDEX + 2000
            });
            userAccuracy = new google.maps.Circle({
              map,
              center: latlng,
              radius: accuracy || 10,
              strokeColor: '#56d364',
              strokeOpacity: 0.4,
              strokeWeight: 1,
              fillColor: '#56d364',
              fillOpacity: 0.1,
              zIndex: 5
            });
            $('btnFollow').disabled = false;
          } else {
            userMarker.setPosition(latlng);
            userAccuracy.setCenter(latlng);
            userAccuracy.setRadius(accuracy || 10);
          }

          $('gpsInfo').textContent = `Lat: ${latitude.toFixed(6)}  Lng: ${longitude.toFixed(6)}  ±${Math.round(accuracy)} m`;
          if (followPos) map.panTo(latlng);
        },
        (err) => {
          setError('GPS errore: ' + err.message + (location.protocol !== 'https:' ? ' (usa HTTPS per sbloccare la geolocalizzazione)' : ''));
          toggleGPS(); // spegne lo stato
        },
        { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 }
      );
    }
  </script>
</body>
</html>

